module.exports.parse = async ({ content }, { notify }) => {
  const webshare = {
    name: "WebShare-Proxy",
    type: "http",
    server: "138.226.61.228",
    port: 6401,
    username: "odcrklvu",
    password: "atoiz9csk0tc",
  };

  const upsertByName = (arr, item) => {
    const i = arr.findIndex((x) => x && x.name === item.name);
    if (i >= 0) arr[i] = { ...arr[i], ...item };
    else arr.push(item);
  };

  const upsertGroup = (groups, g) => {
    const idx = groups.findIndex((x) => x && x.name === g.name);
    if (idx >= 0) {
      const old = groups[idx];

      // relay çš„ proxies é¡ºåºå¾ˆé‡è¦ï¼šå¼ºåˆ¶è¦†ç›–
      const proxies =
        String(g.type).toLowerCase() === "relay"
          ? (g.proxies || [])
          : Array.from(new Set([...(old.proxies || []), ...(g.proxies || [])]));

      groups[idx] = { ...old, ...g, proxies };
    } else {
      groups.push(g);
    }
  };

  const uniq = (arr) => Array.from(new Set((arr || []).filter(Boolean)));

  // 1) æ³¨å…¥ WebShare-Proxy
  content.proxies = Array.isArray(content.proxies) ? content.proxies : [];
  upsertByName(content.proxies, webshare);

  // 2) æ‰¾å‡ºæ‰€æœ‰â€œé¦™æ¸¯â€èŠ‚ç‚¹
  const hkProxyNames = content.proxies
    .filter(
      (p) =>
        p &&
        typeof p.name === "string" &&
        p.name.includes("é¦™æ¸¯") &&
        p.name !== webshare.name
    )
    .map((p) => p.name);

  // 3) ä¸ºæ¯ä¸ªé¦™æ¸¯èŠ‚ç‚¹ç”Ÿæˆ relayï¼š [åŸèŠ‚ç‚¹, WebShare-Proxy]
  const hkRelayGroups = hkProxyNames.map((name) => ({
    name: `${name}+WebShare`,
    type: "relay",
    proxies: [name, webshare.name],
  }));

  // 4) é¦™æ¸¯æ€»é€‰æ‹©ç»„ï¼ˆå¯é€‰ï¼Œä½†å¾ˆæ–¹ä¾¿ï¼‰
  const hkSelectGroup =
    hkRelayGroups.length > 0
      ? {
          name: "ğŸ‡­ğŸ‡°HKä¸¨é¦™æ¸¯+WebShare",
          type: "select",
          proxies: hkRelayGroups.map((g) => g.name),
        }
      : null;

  // 5) åˆå¹¶ proxy-groupsï¼šæ³¨å…¥ HK relay / HK æ€»ç»„ / Proxy-Chain
  content["proxy-groups"] = Array.isArray(content["proxy-groups"])
    ? content["proxy-groups"]
    : [];

  for (const g of hkRelayGroups) upsertGroup(content["proxy-groups"], g);
  if (hkSelectGroup) upsertGroup(content["proxy-groups"], hkSelectGroup);

  const proxyChain = {
    name: "Proxy-Chain",
    type: "select",
    proxies: uniq(["DIRECT", ...(hkSelectGroup ? [hkSelectGroup.name] : [])]),
  };
  upsertGroup(content["proxy-groups"], proxyChain);

  // 6) æŠŠæ‰€æœ‰é relay çš„ proxy-group é‡Œå‡ºç°çš„â€œé¦™æ¸¯èŠ‚ç‚¹â€æ›¿æ¢æˆ â€œé¦™æ¸¯èŠ‚ç‚¹+WebShareâ€
  const hkMap = Object.fromEntries(
    hkProxyNames.map((n) => [n, `${n}+WebShare`])
  );

  for (const g of content["proxy-groups"]) {
    if (!g || !Array.isArray(g.proxies)) continue;
    if (String(g.type).toLowerCase() === "relay") continue; // é¿å…åµŒå¥— relay

    g.proxies = uniq(g.proxies.map((p) => hkMap[p] || p));
  }

  // 7) rulesï¼šç¡®ä¿æœ€ååªæœ‰ä¸€ä¸ªå…œåº• MATCH,Proxy-Chain
  const finalRule = "MATCH,Proxy-Chain";
  content.rules = Array.isArray(content.rules) ? content.rules : [];

  content.rules = content.rules.filter(
    (r) => !(typeof r === "string" && r.trim().toUpperCase().startsWith("MATCH,"))
  );

  if (!content.rules.includes(finalRule)) content.rules.push(finalRule);

  notify &&
    notify(
      "Mixin",
      hkProxyNames.length
        ? `å·²æ³¨å…¥ WebShareï¼Œå¹¶å°†â€œé¦™æ¸¯â€èŠ‚ç‚¹æ›¿æ¢ä¸º +WebShare relayï¼ˆå…± ${hkProxyNames.length} ä¸ªï¼‰ï¼Œè¿½åŠ  MATCH,Proxy-Chain`
        : "å·²æ³¨å…¥ WebShare / Proxy-Chainï¼Œå¹¶è¿½åŠ  MATCH,Proxy-Chainï¼ˆæœªæ£€æµ‹åˆ°åŒ…å«â€œé¦™æ¸¯â€çš„èŠ‚ç‚¹ï¼‰",
      true
    );

  return content;
};
